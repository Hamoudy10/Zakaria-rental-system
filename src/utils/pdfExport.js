// /src/utils/pdfExport.js - UPDATED & FIXED VERSION
import jsPDF from 'jspdf';

// Try to import jspdf-autotable with error handling
let autoTableAvailable = false;
try {
  // Try different import methods
  require('jspdf-autotable');
  autoTableAvailable = true;
} catch (error) {
  console.warn('jspdf-autotable not available as module, trying other methods...');
}

// Check if autoTable is available on jsPDF
if (typeof window !== 'undefined') {
  // In browser context, check if it's available globally
  autoTableAvailable = autoTableAvailable || (window.jsPDF && window.jsPDF.API.autoTable);
}

// Company branding
const COMPANY_NAME = 'Zakaria Housing Agency Limited';
const COMPANY_ADDRESS = 'Mombasa, Kenya';
const COMPANY_PHONE = '+254 XXX XXX XXX';

export const exportToPDF = (config) => {
  const {
    reportType,
    data,
    filters,
    companyInfo,
    user,
    title = 'Report'
  } = config;

  // Check if we have data to export
  if (!data || data.length === 0) {
    console.error('No data to export to PDF');
    alert('No data available to export. Please generate a report first.');
    return;
  }

  try {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    
    // Add header with logo placeholder
    doc.setFontSize(20);
    doc.setTextColor(40, 40, 40);
    doc.text(companyInfo?.name || COMPANY_NAME, pageWidth / 2, 20, { align: 'center' });
    
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.text(COMPANY_ADDRESS, pageWidth / 2, 28, { align: 'center' });
    doc.text(COMPANY_PHONE, pageWidth / 2, 34, { align: 'center' });
    
    // Add report title
    doc.setFontSize(16);
    doc.setTextColor(0, 0, 0);
    doc.text(title, pageWidth / 2, 45, { align: 'center' });
    
    // Add report info
    doc.setFontSize(10);
    doc.setTextColor(80, 80, 80);
    
    let yPos = 55;
    
    // Generated info
    const userName = user?.first_name && user?.last_name 
      ? `${user.first_name} ${user.last_name}`
      : 'Agent';
    const userRole = user?.role || 'agent';
    
    doc.text(`Generated by: ${userName} (${userRole})`, 14, yPos);
    yPos += 7;
    doc.text(`Generated on: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, 14, yPos);
    yPos += 7;
    doc.text(`Total Records: ${data.length}`, 14, yPos);
    yPos += 7;
    
    // Filters info
    if (filters?.startDate || filters?.endDate) {
      const dateRange = `${filters.startDate || 'Start'} to ${filters.endDate || 'End'}`;
      doc.text(`Date Range: ${dateRange}`, 14, yPos);
      yPos += 7;
    }
    
    if (filters?.search) {
      doc.text(`Search: ${filters.search}`, 14, yPos);
      yPos += 7;
    }
    
    // Add a line separator
    doc.setDrawColor(200, 200, 200);
    doc.line(14, yPos + 2, pageWidth - 14, yPos + 2);
    yPos += 10;
    
    // Prepare table data based on report type
    const { headers, rows } = prepareTableData(reportType, data);
    
    // Check if autoTable is available
    if (autoTableAvailable && doc.autoTable) {
      try {
        // Use autoTable for formatted tables
        doc.autoTable({
          head: [headers],
          body: rows,
          startY: yPos,
          margin: { left: 14, right: 14 },
          headStyles: {
            fillColor: [59, 130, 246], // blue-500
            textColor: [255, 255, 255],
            fontSize: 10,
            fontStyle: 'bold'
          },
          bodyStyles: {
            fontSize: 9
          },
          alternateRowStyles: {
            fillColor: [248, 250, 252]
          },
          theme: 'striped'
        });
        
        const finalY = doc.lastAutoTable.finalY || yPos;
        yPos = finalY + 10;
      } catch (autoTableError) {
        console.error('AutoTable error, using fallback:', autoTableError);
        yPos = createFallbackTable(doc, headers, rows, yPos, pageWidth);
      }
    } else {
      // Use fallback table method
      console.warn('jspdf-autotable not available, using basic table');
      yPos = createFallbackTable(doc, headers, rows, yPos, pageWidth);
    }
    
    // Add footer with page numbers
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    doc.text(`${companyInfo?.name || COMPANY_NAME} - Confidential Report`, pageWidth / 2, 285, { align: 'center' });
    
    // Save the PDF
    const fileName = `${reportType}_report_${new Date().getTime()}.pdf`;
    doc.save(fileName);
    
  } catch (error) {
    console.error('PDF export error:', error);
    alert(`Failed to export PDF: ${error.message}. Please check console for details.`);
  }
};

// Fallback table creation when autoTable is not available
const createFallbackTable = (doc, headers, rows, startY, pageWidth) => {
  let yPos = startY;
  const colWidths = [30, 40, 40, 30, 30]; // Fixed column widths
  
  // Draw table header
  doc.setFontSize(10);
  doc.setFont(undefined, 'bold');
  doc.setTextColor(255, 255, 255);
  
  // Draw header background
  doc.setFillColor(59, 130, 246); // blue-500
  doc.rect(14, yPos, pageWidth - 28, 8, 'F');
  
  // Draw header text
  doc.setTextColor(255, 255, 255);
  let xPos = 16;
  headers.forEach((header, index) => {
    const truncatedHeader = header.length > 15 ? header.substring(0, 12) + '...' : header;
    doc.text(truncatedHeader, xPos, yPos + 6);
    xPos += colWidths[index] || 40;
  });
  
  yPos += 10;
  
  // Draw table rows
  doc.setFont(undefined, 'normal');
  doc.setTextColor(0, 0, 0);
  
  rows.slice(0, 30).forEach((row, rowIndex) => {
    // Check if we need a new page
    if (yPos > 270) {
      doc.addPage();
      yPos = 20;
    }
    
    // Alternate row colors
    if (rowIndex % 2 === 0) {
      doc.setFillColor(248, 250, 252); // gray-50
      doc.rect(14, yPos - 2, pageWidth - 28, 8, 'F');
    }
    
    // Draw row data
    xPos = 16;
    row.forEach((cell, cellIndex) => {
      const cellText = String(cell || '').length > 20 
        ? String(cell || '').substring(0, 17) + '...' 
        : String(cell || '');
      doc.text(cellText, xPos, yPos + 4);
      xPos += colWidths[cellIndex] || 40;
    });
    
    yPos += 8;
  });
  
  return yPos;
};

const prepareTableData = (reportType, data) => {
  // Default headers and data mapping
  let headers = ['ID', 'Name', 'Date', 'Amount', 'Status'];
  let rows = [];
  
  switch (reportType) {
    case 'tenants':
      headers = ['Tenant ID', 'Full Name', 'Phone', 'Unit', 'Property', 'Status'];
      rows = data.map(item => [
        item.national_id || item.id?.substring(0, 8) || 'N/A',
        `${item.first_name || ''} ${item.last_name || ''}`.trim() || 'N/A',
        item.phone_number || 'N/A',
        item.unit_code || 'N/A',
        item.property_name || item.name || 'N/A',
        item.is_active ? 'Active' : (item.status || 'Inactive')
      ]);
      break;
      
    case 'payments':
      headers = ['Payment ID', 'Tenant', 'Amount', 'Payment Month', 'Status', 'Date'];
      rows = data.map(item => [
        item.mpesa_receipt_number || item.id?.substring(0, 8) || 'N/A',
        item.tenant_name || `${item.first_name || ''} ${item.last_name || ''}`.trim() || 'N/A',
        `KSh ${(item.amount || 0).toLocaleString()}`,
        item.payment_month || 'N/A',
        item.status || 'Pending',
        item.created_at ? new Date(item.created_at).toLocaleDateString() : new Date().toLocaleDateString()
      ]);
      break;
      
    case 'properties':
      headers = ['Property Code', 'Property Name', 'Address', 'Total Units', 'Available', 'Status'];
      rows = data.map(item => [
        item.property_code || item.id?.substring(0, 8) || 'N/A',
        item.name || 'N/A',
        item.address || 'N/A',
        item.total_units || item.unit_count || 0,
        item.available_units || item.available_units_count || 0,
        'Active'
      ]);
      break;
      
    case 'complaints':
      headers = ['Complaint ID', 'Title', 'Tenant', 'Property', 'Status', 'Priority'];
      rows = data.map(item => [
        item.id?.substring(0, 8) || 'N/A',
        item.title || 'N/A',
        item.tenant_name || `${item.first_name || ''} ${item.last_name || ''}`.trim() || 'N/A',
        item.property_name || 'N/A',
        item.status || 'Open',
        item.priority || 'Medium'
      ]);
      break;
      
    case 'water':
      headers = ['Water Bill ID', 'Tenant', 'Property', 'Month', 'Amount', 'Status'];
      rows = data.map(item => [
        item.id?.substring(0, 8) || 'N/A',
        item.tenant_name || `${item.first_name || ''} ${item.last_name || ''}`.trim() || 'N/A',
        item.property_name || 'N/A',
        item.bill_month || 'N/A',
        `KSh ${(item.amount || 0).toLocaleString()}`,
        item.status || 'Pending'
      ]);
      break;
      
    case 'sms':
      headers = ['SMS ID', 'Phone', 'Message Type', 'Status', 'Sent Date', 'Error'];
      rows = data.map(item => [
        item.id?.substring(0, 8) || 'N/A',
        item.recipient_phone || item.phone_number || 'N/A',
        item.message_type || 'N/A',
        item.status || 'Pending',
        item.sent_at || item.created_at ? new Date(item.sent_at || item.created_at).toLocaleDateString() : 'N/A',
        item.error_message?.substring(0, 30) || 'None'
      ]);
      break;
      
    case 'revenue':
      headers = ['Revenue ID', 'Month', 'Property', 'Total Amount', 'Payment Count', 'Average'];
      rows = data.map(item => [
        item.id?.substring(0, 8) || 'N/A',
        item.month || item.payment_month || new Date().toISOString().slice(0, 7),
        item.property_name || 'All Properties',
        `KSh ${(item.total_revenue || item.amount || 0).toLocaleString()}`,
        item.payment_count || 1,
        `KSh ${Math.round((item.average_payment || item.amount || 0)).toLocaleString()}`
      ]);
      break;
      
    default:
      rows = data.map((item, index) => [
        index + 1,
        item.name || item.first_name || item.tenant_name || 'N/A',
        item.created_at ? new Date(item.created_at).toLocaleDateString() : new Date().toLocaleDateString(),
        `KSh ${(item.amount || 0).toLocaleString()}`,
        item.status || 'Active'
      ]);
  }
  
  // Ensure all rows have the same number of columns as headers
  rows = rows.map(row => {
    while (row.length < headers.length) {
      row.push('N/A');
    }
    return row.slice(0, headers.length); // Trim if longer
  });
  
  return { headers, rows };
};

// Helper function to check if jspdf-autotable is available
export const checkAutoTableAvailability = () => {
  return autoTableAvailable;
};

// Initialize function
export const initializePDFExport = () => {
  console.log('PDF Export initialized. AutoTable available:', autoTableAvailable);
  return autoTableAvailable;
};